JavaScript 具有垃圾自动回收机制（Garbage Collection）简称 GC。垃圾回收机制会中断整个代码执行，释放不可能再被使用的变量，释放内存，这个工作机制是周期性的， 



## 可释放对象·

```
function fn1() {
  var obj1 = { name: 'xiaomuchen', age: '20' }
}
function fn2() {
  var obj2 = { name: 'xiaomuchen', age: '20' }
  return obj2
}
var a = fn1()
var b = fn2()
console.log(a, b) // undefined, {name: "xiaomuchen", age: "20"}
```

我们对比上面两个函数，fn1 在函数内声明变量 obj1 并且赋值，在函数执行后这个变量`便不可再访问了`，fn2 在最后把函数内的变量 obj2 返回到全局变量 b，所以 `{ name: 'xiaomuchen', age: '20' }` 这个对象（或者说 obj2）`依然可被访问`。

JavaScript 回收机制通过判断变量是否可被访问，来决定回收哪些变量。



### 标记清除和引用计数

JavaScript 是如何判断变量是否可被访问？这就要提到标记清除和引用计数。

标记清除：标记清除是目前大部分 JavaScript 引擎使用的判断方式，通过标记变量的状态来确定是否可被回收。当变量在环境中被声明时标记`进入环境`，理论上永远不要释放进入环境的变量，因为它可以在环境中的任何位置、任何时刻被访问。当环境被销毁（如函数执行完），则变量被标记`离开环境`等待回收。

```
function fn(){
  var a = { count: 10 } // 被标记，进入环境 
  var b = { count: 20 } // 被标记，进入环境
}
fn(); // 执行完毕之后 b 被标记，离开环境
```

### 引用计数

引用计数：JavaScript 引擎维护一张`引用表`，保存内存中所有的资源的引用次数。资源被引用一次则引用 +1，资源被去掉引用或者退出变量的函数作用域时，则引用 -1，当资源的引用次数为`0`时，说明无法访问这个值，则等待回收。 （注：引用计数从 1 到 0 这个过程可能不执行，而是直接标记`可被回收`，不再进行加减运算节约开销） 

```
function fn(){
  var a = { count: 10 } // 资源 { count: 10 } 被引用次数为 1
  a = { count: 20 } // 资源 { count: 20 } 被引用次数为 1，资源 { count: 10 } 被引用次数为 0，等待回收
  // do someThing
}
fn(); // 资源 { count: 20 } 被释放
```



//缺陷

```
function fn(){
  var a = { count: 10 }
  var b = { count: 20 }
  a.param = b // b 的引用次数为 2
  b.param = a // a 的引用次数为 2
}
fn(); // a、b 的引用次数为 1
```



理论上不回收。因为闭包中的变量不会被回收这是闭包的特性之一。 但是实际上不同的浏览器实现的可能不一样。一些高端浏览器如果确认这个变量没有且不会再被使用的话，也可能将其回收。 